#!/usr/bin/env python

# vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4

import csv
import datetime
import itertools
import os
import subprocess

import numpy as np
from scipy import signal as sig
from scipy import stats
from matplotlib import dates
import matplotlib.pyplot as plt
import matplotlib.colors

from replot import Axes as OldAxes
from replot import PlotWidget as OldPlotWidget
from replot import custom_result, Figure, _PlotResultCanvas
import gtk.gdk


# Variable definitions for fitness data acquisition.

# Folder that contains the spreadsheet.
folder = os.path.join(os.getenv("HOME"), "Documents", "Fitness")

# File name of the spreadsheet.
filename = "Fitness tracker.ods"

# Sheet that contains measurements.
# Sheet must be named as per this variable.
# Refer to the README.md file for the format.
# The sheet must have the following labels starting at A1:
#   Date    Measurement      Value            Unit             Notes
# Each line on the table must describe an exercise set.
# Each cell on the table starting at A2 must be in the following format:
#   date    string           integer          float/formula    string
measurements_f = "Measurements tracker"

# Sheet that contains exercises.
# Sheet must be named as per this variable.
# Refer to the README.md file for the format.
# The sheet must have the following labels starting at A1:
#   Date    Exercise name    Repetitions      Weight           Notes
# Each line on the table must describe a measurement (e.g. of your body).
# Each cell on the table starting at A2 must be in the following format:
#   date    string           float/formula    string           string
exercise_f = "Exercise tracker"


class PlotWidget(OldPlotWidget):

    def __init__(self, result, width=None, height=None):
        apply(custom_result.ResultWidget.__init__, (self,))

        if width and height:
            figsize=(width, height)
        elif result.display == 'side':
           figsize=(9,6)
        else:
           figsize=(12,6)

        self.figure = Figure(facecolor='white', figsize=figsize)
        self.canvas = _PlotResultCanvas(self.figure)

        self.axes = self.figure.add_subplot(111)

        self.add_events(gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE)

        self.cached_contents = None


class Axes(OldAxes):

    def __init__(self, width=None, height=None, subplots_adjust_parms=None):
        apply(OldAxes.__init__, (self,))
        self.figure_width = width
        self.figure_height = height
        self.subplots_adjust_parms = subplots_adjust_parms

    def create_widget(self):
        widget = PlotWidget(self, self.figure_width, self.figure_height)
        self.figure = widget.figure
        if self.subplots_adjust_parms:
            self.figure.subplots_adjust(**self.subplots_adjust_parms)
        self._replay(widget.axes)
        return widget


def merge_over_time(datapoints, func):
    new_dates, indices = np.unique(datapoints['dates'], return_index=True)
    new_data = np.zeros(len(indices), dtype=float)
    for n, idx in enumerate(np.nditer(indices)):
        try:
            value = func(datapoints['values'][idx:indices[n+1]])
        except IndexError:
            value = func(datapoints['values'][idx:])
        new_data[n] = value
    return {
        'dates': new_dates,
        'values': new_data,
        'unit': datapoints['unit']
    }


def sum_over_time(datapoints):
    return merge_over_time(datapoints, sum)


def mean_over_time(datapoints):
    return merge_over_time(datapoints, np.average)


def strpdate(d):
    return datetime.datetime.strptime(d, "%Y-%m-%d").date()


def extract_data():
    measurements_p = os.path.join(folder, measurements_f + ".csv")
    exercise_p = os.path.join(folder, exercise_f + ".csv")

    odsmtime = os.stat(os.path.join(folder, filename)).st_mtime
    try:
        csvmtime1 = os.stat(measurements_p).st_mtime
        csvmtime2 = os.stat(exercise_p).st_mtime
    except Exception:
        csvmtime1 = 0
        csvmtime2 = 0


    if odsmtime > csvmtime1 or odsmtime > csvmtime2:
        apply(subprocess.check_call, ([
            "ssconverter", "-m",
            os.path.join(folder, filename) + ":" + measurements_f,
            measurements_p
        ],))
        apply(subprocess.check_call, ([
            "ssconverter", "-m",
            os.path.join(folder, filename) + ":" + exercise_f,
            exercise_p
        ],))

    reps_data = {}
    weight_data = {}

    with open(exercise_p) as f:
        reader = csv.reader(f, delimiter=",")
        for date, exercise, reps, weight, _ in reader:
            if date == "Date": continue
            if exercise not in reps_data:
                reps_data[exercise] = []
            if exercise not in weight_data:
                weight_data[exercise] = []
            reps_data[exercise].append([
                date,
                float(reps),
                "reps",
            ])
            weight_data[exercise].append([
                date,
                float(weight),
                "lb"
            ])

    measurements_data = {}

    with open(measurements_p) as f:
        reader = csv.reader(f, delimiter=",")
        for date, measurement, value, unit, _ in reader:
            if date == "Date": continue
            if value == "": continue
            if measurement not in measurements_data:
                measurements_data[measurement] = []
            measurements_data[measurement].append([
                date,
                float(value),
                unit
            ])

    def numpyize(stuff):
        res = {}
        for k, v in stuff.items():
            data = np.array([np.array(xi) for xi in v])
            data = data.transpose()
            data_dates = np.array([dates.datestr2num(x) for x in data[0]])
            data_values = np.array([float(x) for x in data[1]])
            res[k] = {
                'dates': data_dates,
                'values': data_values,
                'unit': data[2][0]
            }
        return res

    return [numpyize(x) for x in [reps_data, weight_data, measurements_data]]


def autosmooth(data_values, smoothing_window_len, polyorder):
    fac = 3
    win = len(data_values) / fac
    if win % 2 == 0:
        win = win + 1
    if win < 5:
        win = 5
    if win > smoothing_window_len:
        win = smoothing_window_len
    try:
        return sig.savgol_filter(data_values, win, polyorder)
    except Exception:
        print "sig savgol filter failed with len",
        print len(data_values), "window", win, "polyorder", polyorder


def preplot(values, width, height):
    mindata = np.min(values)
    data_zeros = np.array([mindata for x in values])
    axes = Axes(width=width, height=height,
                subplots_adjust_parms={'bottom': 0.11,
                                       'left': 0.06,
                                       'right': 1.0})
    return data_zeros, axes


def postplot(axes, title, data_dates, data_values, trend_line_width, date_limits, smoothing_window_len, forecast_past_sample_count):
    interp_dates = np.linspace(data_dates[0], data_dates[-1], data_dates[-1] - data_dates[0] + 1)
    interp_values = np.interp(interp_dates, data_dates, data_values)

    forecast_length = 14
    smooth_order = 2

    date_limits = (date_limits[0], date_limits[-1] + forecast_length)

    trend_values = None
    smoothed_values = autosmooth(interp_values, smoothing_window_len, smooth_order)
    if smoothed_values is not None:
        axes.plot(interp_dates, smoothed_values, "--",
                  linewidth=trend_line_width, color='g')

        for d, v, o in [(data_dates, data_values, 1)]:
            factors = np.polyfit(d[-forecast_past_sample_count:],
                                 v[-forecast_past_sample_count:],
                                 o)
            trend = np.poly1d(factors)
            trend_dates = np.linspace(data_dates[-1],
                                      date_limits[-1],
                                      data_dates[-1] - date_limits[0] + 1)
            trend_values = [trend(t) for t in trend_dates]
            diff = smoothed_values[-1] - trend_values[0]
            trend_values = trend_values + diff
            axes.plot(trend_dates,
                      trend_values,
                      ":", linewidth=trend_line_width, color='g')

    if title:
        axes.set_title(title)

    mindate = date_limits[0]
    maxdate = date_limits[-1]
    bins = np.linspace(mindate, maxdate, num=20)
    indexes = np.digitize(data_dates, bins)

    axes.set_xticks(data_dates)
    months_seen = set()
    xticklabels = []
    oldidx = None
    for x, idx in zip(data_dates, indexes):
        x = dates.num2date(x).date()
        if oldidx == idx:
            xticklabels.append("")
        elif x.strftime("%b") in months_seen:
            xticklabels.append(x.strftime("%-d"))
        else:
            months_seen.add(x.strftime("%b"))
            xticklabels.append(x.strftime("%-d\n%b"))
        oldidx = idx
    axes.set_xticklabels(xticklabels, rotation=0, fontsize=8, ha="center")

    axes.set_xlim(*date_limits)

    miny = min(data_values)
    maxy = max(data_values)
    if smoothed_values is not None:
        miny = min([miny, min(smoothed_values), min(trend_values)])
        maxy = max([maxy, max(smoothed_values), max(trend_values)])

    if maxy - miny < 1.0:
        mean = (maxy - miny) / 2.0
        miny = miny - mean
        maxy = maxy + mean

    maxy = maxy * 1.02
    axes.set_ylim([miny, maxy])


def daterange(data):
    dates = set()
    for k, v in data.items():
        for date in v['dates']:
            dates.add(date)
    return min(dates), max(dates)


def plot_measurements(measurement_data,
                      date_limits,
                      trend_line_width=2,
                      width=9,
                      height=3,
                      title=None,
                      smoothing_window_len=13):
    date_limits = (date_limits[0], date_limits[-1])

    data_zeros, axes = preplot(measurement_data['values'], width, height)
    axes.plot(measurement_data['dates'], measurement_data['values'])

    postplot(axes, title, measurement_data['dates'],
             measurement_data['values'], trend_line_width,
             date_limits, smoothing_window_len,
             forecast_past_sample_count=14)

    return axes


def plot_exercises(exercise_data,
                   reps_data,
                   date_limits,
                   bar_width=10,
                   trend_line_width=2,
                   width=9,
                   height=3,
                   title=None,
                   smoothing_window_len=13):
    date_limits = (date_limits[0] - 1, date_limits[-1] + 1)

    exercise_data = mean_over_time(exercise_data)
    reps_data = sum_over_time(reps_data)
    reps_mode = stats.mode(reps_data['values'])[0]

    def getcolor(x):
        if x >= reps_mode:
            return 'g'
        hue = x / reps_mode * 0.1
        return matplotlib.colors.hsv_to_rgb([hue, 1, 1])

    barcolors = [getcolor(x) for x in reps_data['values']]
    _, axes = preplot(exercise_data['values'], width, height)
    axes.vlines(exercise_data['dates'],
                [0.0 for _ in exercise_data['values']],
                exercise_data['values'],
                color=barcolors,
                lw=bar_width)

    postplot(axes, title, exercise_data['dates'],
             exercise_data['values'], trend_line_width,
             date_limits, smoothing_window_len,
             forecast_past_sample_count=3)
    return axes


reps_data, weight_data, measurement_data = extract_data()
date_limits = daterange(measurement_data)
# date_limits = [dates.datestr2num('2017-02-27'), date_limits[1]]


sane_sort_order = lambda m: "w" if m[1]['unit'] == "%" else m[1]["unit"] + m[0]
sorted_measurement_data = sorted(measurement_data.items(), key=sane_sort_order)
for blob in sorted_measurement_data:
    typ, data = blob
    plot_measurements(data, date_limits,
                      title=typ + " (" + data['unit'] + ")")


for typ in reps_data:
    plot_exercises(weight_data[typ], reps_data[typ], date_limits,
                   title=typ + " (" + weight_data[typ]['unit'] + ")")
